<?php

/*Задание 2

Дан код:

class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
$a1 = new A();
$a2 = new A();
$a1->foo();
$a2->foo();
$a1->foo();
$a2->foo();

Что он выведет на каждом шаге? Почему?

    Немного изменим п.5

class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
class B extends A {
}
$a1 = new A();
$b1 = new B();
$a1->foo();
$b1->foo();
$a1->foo();
$b1->foo();

Что он выведет теперь?*/



// Первая часть кода
//echo "Первая часть:\n";

/*class A {
    public function foo() {
        static $x = 0; // Статическая переменная, сохраняет свое значение
        echo ++$x . "\n"; // Увеличиваем значение на 1 и выводим
    }*/
/*Статическая переменная:

    static $x = 0; инициализирует переменную $x только один раз, при первом вызове метода foo().
После первого вызова, значение $x сохраняется между вызовами метода.*/
//}

//$a1 = new A();
//$a2 = new A();

/*Вызовы:

Когда вызывается $a1->foo(), переменная $x увеличивается с 0 до 1 и выводится.
При следующем вызове $a2->foo(), переменная $x уже равна 1, поэтому она увеличивается до 2 и выводится.
При следующих вызовах переменная просто продолжает увеличиваться, что даёт вывод 3 и 4.*/

//$a1->foo(); // Выводит 1
//$a2->foo(); // Выводит 2
//$a1->foo(); // Выводит 3
//$a2->foo(); // Выводит 4

// Разделяем результаты выводом пустой строки
//echo "\n";

// Вторая часть кода
echo "Вторая часть:\n";

class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}

/*Теперь у нас есть два класса: A и B, где класс B наследует класс A.
Однако, несмотря на наследование, статические переменные не
разделяются между классами и их наследниками. У каждого
класса своя собственная статическая переменная.*/
class B extends A { // Подкласс B наследует от A
}

$a1 = new A(); // Новый экземпляр класса A
$b1 = new B(); // Новый экземпляр подкласса B

/*Класс A использует свою статическую переменную $x,
и она инициализируется значением 0.
После инкремента переменная становится равной 1.*/

$a1->foo(); // Выводит 1

/*Класс B наследует метод foo() от A, но у класса B будет
своя отдельная статическая переменная $x,
которая также инициализируется значением 0.
После инкремента она становится равной 1.*/

$b1->foo(); // Выводит 1 (новая статическая переменная)

/*Вызов метода для объекта a1 класса A снова инкрементирует
статическую переменную $x класса A, увеличив ее значение до 2.*/

$a1->foo(); // Выводит 2

/*Вызов метода для объекта b1 класса B снова инкрементирует
статическую переменную $x класса B. Переменная $x для класса
B была равна 1 после первого вызова, теперь она увеличивается до 2.*/
$b1->foo(); // Выводит 2 (новая статическая переменная для класса B)

/*Вывод:
В первой части задачи все объекты класса A используют одну и ту же
статическую переменную $x. Поэтому каждый вызов метода foo()
увеличивает одну и ту же переменную, что приводит к выводу 1 2 3 4.

Во второй части задачи у нас есть два класса: A и его наследник B.
Несмотря на то, что класс B наследует метод foo(),
статическая переменная $x разделяется между классами A и B.
У каждого класса своя версия переменной $x:

Вызовы метода для объекта класса A работают с одной статической переменной.
Вызовы метода для объекта класса B работают с другой статической переменной.
Это приводит к выводу 1 1 2 2, так как статические переменные
каждого класса увеличиваются отдельно друг от друга.*/

/*Важное замечание
Статические переменные относятся к методу, в котором они были определены.
Это значит, что если метод foo() определен в классе A,
то все статические переменные этого метода будут принадлежать
именно классу A. Класс B, наследуя от A, не получает
доступа к статическим переменным, если только он не переопределяет метод foo().

Если мы хотим, чтобы метод foo() в классе B имел свои собственные
статические переменные, нужно переопределить метод.*/

/*Заключение
Если мы хотим избежать проблем с кэшированием статических переменных,
наиболее безопасный способ — не использовать их в тех ситуациях,
где необходимо, чтобы каждое создание экземпляра класса имело своё состояние.
Вместо этого нужно рассмотреть возможность использования экземплярных
переменных или переопределения методов в наследуемых классах.*/